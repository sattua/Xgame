<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
</script>
<!DOCTYPE html>
<html>
<head>
  <title>Downhill Dash</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
<script>
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const SKIER_WIDTH = 500;
const SKIER_HEIGHT = 500;
const SKIER_Y_OFFSET = 10;
const SKIER_START_Y = CANVAS_HEIGHT - 100;
const SKIER_JUMP_HEIGHT = 50;
const SKIER_JUMP_DURATION = 20; // frames
const OBSTACLE_SIZE = 30;
const OBSTACLE_X_OFFSET = 15;
const OBSTACLE_SPAWN_INTERVAL = 60; // frames
const DIFFICULTY_INTERVAL = 300; // frames
const INITIAL_SLOPE_SPEED = 5;
const LANE_POSITIONS = [CANVAS_WIDTH / 4, CANVAS_WIDTH / 2, 3 * CANVAS_WIDTH / 4];

const SPRITE_WIDTH = 600;   // width of one pose in the sprite sheet
const SPRITE_HEIGHT = 600;  // height of one pose
let skierSprite;

let skier;
let obstacles = [];
let score = 0;
let gameOver = false;
let slopeSpeed = INITIAL_SLOPE_SPEED;
let gameStarted = false;
let skierImg;

function preload() {
  skierSprite = loadImage('sprite.png'); // Your sprite sheet file
  console.log('[info] Load once before setup');
}

function setup() {
  createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
  skier = {
    lane: 1,
    y: SKIER_START_Y,
    isJumping: false,
    jumpHeight: SKIER_JUMP_HEIGHT,
    jumpTime: 0,
    lanePositions: LANE_POSITIONS
  };
  spawnObstacle();
}

function draw() {
  if (!skierSprite) {
    console.log("Image not loaded!");
  }
  // Draw scrolling background
  background(200, 220, 255);
  fill(255);
  rect(0, 0, width, height);

  // Lane markers
  fill(220);
  rect(LANE_POSITIONS[0] - 10, 0, 20, height);

  rect(LANE_POSITIONS[2] - 10, 0, 20, height);

  fill(200, 200, 255);

  rect(LANE_POSITIONS[1] - 10, 0, 20, height);



  if (!gameStarted) {
    fill(0);
    textSize(40);
    textAlign(CENTER);
    text("Downhill Dash", width / 2, height / 2 - 40);
    textSize(20);
    text("Use LEFT/RIGHT arrows to switch lanes (Left, Center, Right)", width / 2, height / 2);
    text("Use UP arrow to jump over obstacles", width / 2, height / 2 + 30);
    text("Press S to Start", width / 2, height / 2 + 60);
    return;
  }

  if (!gameOver) {

    // Handle jumping
    let skierY = skier.y;
    if (skier.isJumping) {
      let jumpProgress = (frameCount - skier.jumpTime) / SKIER_JUMP_DURATION;
      if (jumpProgress < 1) {
        skierY -= skier.jumpHeight * sin(PI * jumpProgress);
      } else {
        skier.isJumping = false;
      }
    }

    // Draw skier
    let poseIndex = getSkierPose();
    let skierX = skier.lanePositions[skier.lane] - 70; // TODO clean hardcoded numbers
    let skierYAdjusted = skierY - SKIER_Y_OFFSET;
    let scaleX = 100;
    let scaleY = scaleX;

    let cropInitX = 980;
    let cropInitY = 0;

    if(skier.lane === 0) {
      cropInitX = 0; // left lane
    } else if (skier.lane === 2) {
      cropInitX = 600; // right lane
    } 

    if (skier.isJumping) {
      cropInitY = 620; 
    }
    
    image(skierSprite, skierX, skierYAdjusted, scaleX, scaleY, cropInitX, cropInitY, SPRITE_WIDTH, SPRITE_HEIGHT);

    // Update and draw obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
      let obs = obstacles[i];
      obs.y += slopeSpeed;
      fill(100);
      rect(obs.lanePositions[obs.lane] - OBSTACLE_X_OFFSET, obs.y, OBSTACLE_SIZE, OBSTACLE_SIZE);

      // Check collision
      if (!skier.isJumping &&
          obs.y > skier.y - OBSTACLE_SIZE && obs.y < skier.y + OBSTACLE_SIZE &&
          obs.lane === skier.lane) {
        gameOver = true;
      }

      // Remove obstacles that are off-screen and increment score
      if (obs.y > CANVAS_HEIGHT) {
        obstacles.splice(i, 1);
        score += 1;
      }
    }

    // Spawn new obstacles
    if (frameCount % OBSTACLE_SPAWN_INTERVAL === 0) {
      spawnObstacle();
    }

    // Increase difficulty
    if (frameCount % DIFFICULTY_INTERVAL === 0) {
      slopeSpeed += 0.5;
    }
  } else {
    fill(255, 0, 0);
    textSize(40);
    textAlign(CENTER);
    text("Game Over! Score: " + score, width / 2, height / 2);
    textSize(20);
    text("Press R to Restart", width / 2, height / 2 + 40);
  }

  // Draw score
  fill(0);
  textSize(20);
  textAlign(LEFT);
  text("Score: " + score, 20, 30);
}

// Helper to get skier pose index
function getSkierPose() {
  if (skier.isJumping) {
    if (skier.lane === 0) return 3; // jump left
    if (skier.lane === 2) return 4; // jump right
    return 5; // jump straight
  } else {
    if (skier.lane === 0) return 0; // move left
    if (skier.lane === 2) return 1; // move right
    return 2; // move straight
  }
}

function spawnObstacle() {
  let lane = floor(random(3));
  obstacles.push({
    lane: lane,
    y: 0,
    lanePositions: LANE_POSITIONS
  });
}

function keyPressed() {
  if (!gameStarted && keyCode === 83) { // 'S' to start
    gameStarted = true;
  }

  if (gameOver && keyCode === 82) { // 'R' to restart
    obstacles = [];
    score = 0;
    gameOver = false;
    slopeSpeed = 5;
    skier.lane = 1;
    skier.isJumping = false;
    spawnObstacle();
  }

  if (!skier.isJumping) {
    if (keyCode === LEFT_ARROW && skier.lane > 0) {
      skier.lane -= 1;
    } else if (keyCode === RIGHT_ARROW && skier.lane < 2) {
      skier.lane += 1;
    } else if (keyCode === UP_ARROW) {
      skier.isJumping = true;
      skier.jumpTime = frameCount;
    }
  }
}

</script>
</body>
</html>